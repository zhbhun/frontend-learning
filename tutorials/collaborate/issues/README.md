## CRDT 并发下的业务冲突

在 Yjs / Automerge 里，所有操作（insert、delete、set）都会最终收敛。但是业务逻辑上存在额外约束，比如：节点被锁定时，不允许再修改。当出现并发：

1. A 先发出 lock，
2. B 在收到 lock 之前已经做了 edit（本地乐观更新）。

结果：

1. A 看到的是“节点被锁，没有修改”；
2. B 先看到修改成功，后来才发现锁 → 出现 不一致 / 冲突。

👉 核心矛盾：CRDT 只保证最终一致性，不会帮你处理业务约束冲突。

解决方案

针对这种 race condition（锁与编辑并发）的冲突，可以有两大思路：

- 回滚模式（Reject + Undo）：客户端的操作要得到服务端确认，否则就撤销。

  流程：

    1. B 乐观更新，先改。
    2. 服务端收到 edit → 发现该节点已锁 → 拒绝操作。
    3. 服务端返回 "editRejected"。
    4. B 收到后执行 逆操作（回滚），恢复原状态。

  特点：

    1. 一致性强，和服务端完全同步。
    2. 用户体验：先看到修改 → 一下子被撤销（闪回）。
    3. 技术要求：客户端维护操作日志 + undo 逻辑。

- 裁决规则模式（Merge Resolution）：让 CRDT 合并时，通过全局一致的规则裁决。

  流程：

    1. B 乐观更新，先改。
    2. A 发出 lock。
    3. CRDT 合并时，根据规则（例如 “lock 优先于 edit”）：
    4. lock 时间戳 < edit → edit 丢弃。
    5. edit 时间戳 < lock → edit 保留，但锁定后禁止再改。
    6. 所有端自动收敛到同一个最终状态。

  特点：

    1. 无需显式回滚，客户端只是被 远端状态覆盖。
    2. 用户体验：修改没生效，但没有提示。
    3. 技术要求：定义清晰的冲突裁决规则（基于时间戳、权限、优先级等）。
