# 设计模式

## 设计原则

### 单一责任原则

单一责任原则（Single Responsibility Principle）。

- 简介：一个对象(方法)只做一件事情。

    单一职责原则(SRP)的职责被定义为“引起变化的原因”。如果我们有两个动机去改写一个方法，那么这个方法就具有两个职责。每个职责都是变化的一个轴线，如果一个方法承担了过 多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。此时，这个方法通常是一个不稳定的方法，修改代码总是一件危险的事情，特别是当两个职 责耦合在一起的时候，一个职责发生变化可能会影响到其他职责的实现，造成意想不到的破坏， 这种耦合性得到的是低内聚和脆弱的设计。

- 模式：

    - 代理模式：将一些对象访问控制逻辑提取到代理层，保证原有对象职责的单一性。
    - 迭代器模式：将对象或数组的遍历逻辑单独提取出来。

- 总结：SRP 原则是所有原则中最简单也是最难正确运用的原则之一。

    我们要明确的是，并不是所有的职责都应该一一分离。一方面，如果随着需求的变化，有两个职责总是同时变化，那就不必分离他们。另一方面，职责的变化轴线仅当它们确定会发生变化时才具有意义，即使两个职责已经被耦 合在一起，但它们还没有发生改变的征兆，那么也许没有必要主动分离它们，在代码需要重构的 时候再进行分离也不迟。

### 里氏代换原则

TODO

### 依赖倒置原则

TODO

### 接口隔离原则

接口隔离原则（Interface Segregatio Principle）。

- 简介：接口隔离原则是对接口的定义，同时也是对类的定义，接口和类尽量使用**原子接口或原子类**来组装。

    误区：贯彻接口隔离原则的最好方法是一个接口一个方法，保证绝对符合接口隔离原则.

- 总结：根据经验和常识决定接口的粒度大小，接口粒度太小，导致接口数据剧增，开发人员呛死在接口的海洋里；接口粒度太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。

    思考：前端组件的划分？

### 最少知识原则

最少知识原则（LKP） / 迪米特法则（Law of Demeter）。

- 简介：最少知识原则(LKP)说的是一个软件实体应当尽可能少地与其他实体发生相互作用。这 里的软件实体是一个广义的概念，不仅包括对象，还包括系统、类、模块、函数、变量等。

    单一职责原则指导我们把对象划分成较小的粒度，这可以提高对象的可复用性。但越来越多的对象之间可能会产生错综复杂的联系，如果修改了其中一个对象，很可能会影响到跟它相互引用的其他对象。对象和对象耦合在一起，有可能会降低它们的可复用性。

    > 某军队中的将军需要挖掘一些散兵坑。下面是完成任务的一种方式:将军可以通知 上校让他叫来少校，然后让少校找来上尉，并让上尉通知一个军士，最后军士唤来一个 士兵，然后命令士兵挖掘一些散兵坑。
    
- 模式：

    - 中介者模式：通过增加一个中介者对象，让所有的相关对象都通 过中介者对象来通信，而不是互相引用。所以，当一个对象发生改变时，只需要通知中介者对象 即可。
    - 外观/门面模式：外观模式的作用是对客户屏蔽一组子系统的复杂性。外观模式对客户提供一个简单易用的高 层接口，高层接口会把客户的请求转发给子系统来完成具体的功能实现。大多数客户都可以通过 请求外观接口来达到访问子系统的目的。但在一段使用了外观模式的程序中，请求外观并不是强 制的。如果外观不能满足客户的个性化需求，那么客户也可以选择越过外观来直接访问子系统。

- 总结：

    - 最少知识原则要求我们在设计程序时，应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的相互联系。常见的做法是引入一个第三者对 象，来承担这些对象之间的通信作用。如果一些对象需要向另一些对象发起请求，可以通过第三者对象来转发这些请求。
    - 封装在很大程度上表达的是数据的隐藏。一个模块或者对象可以将内部的数据或者实现细 节隐藏起来，只暴露必要的接口 API 供外界访问。对象之间难免产生联系，当一个对象必须引 用另外一个对象的时候，我们可以让对象只暴露必要的接口，让对象之间的联系限制在最小的 范围之内。

        在设计 React 组件 props 时就是门面模式，通过 props 对外输出组件定制能力，但是一些人为了满足一些需求会强耦合组件内部的实现逻辑。

### 开闭原则

开闭原则（Open Closed Principle）。

> 软件实体(类、模块、函数)等应该是可以扩展的，但是不可修改。

- 简介：当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，但是不允许改动程序的源代码。

    误区：“不允许改动”指的是改动源代码成本往往比较高，可以通过扩展的方式来解决问题。

    > 有一家生产肥皂的大企业，从欧洲花巨资引入了一条生产线。这条生产线可以自动完成从原材料加工到包装成箱的整个流程，但美中不足的是，生产出来的肥皂有一定的 空盒几率。于是老板又从欧洲找来一支专家团队，花费数百万元改造这一生产线，终于 解决了生产出空盒肥皂的问题。
    >
    > 另一家企业也引入了这条生产线，他们同样遇到了空盒肥皂的问题。但他们的解决办法很简单：用一个大风扇在生产线旁边吹，空盒肥皂就会被吹走。
  
    思路：

    - 用对象的多态性消除条件分支：过多的条件分支语句是造成程序违反开放-封闭原则的一个常见原因。每当需要增加一个新的 if 语句时，都要被迫改动原函数。把 if 换成 switch-case 是没有用的，这是一种换汤不换药的做法。实际上，每当我们看到一大片的 if 或者 swtich-case 语句时，第一时间就应该考虑，能否利用对象的多态性来重构它们。
    - 放置挂钩：由于子类的数量是无限制的，总会有一些“个性化”的子类迫使我们不得不去改变已经封装 好的算法骨架。于是我们可以在父类中的某个容易变化的地方放置挂钩，挂钩的返回结果由具体 子类决定。这样一来，程序就拥有了变化的可能。
    - 使用回调函数：回调函数是一种特殊的挂钩。我们可以把一部分易于变化的逻辑封装在回调函数里，然后把 回调函数当作参数传入一个稳定和封闭的函数中。当回调函数被执行的时候，程序就可以因为回 调函数的内部逻辑不同，而产生不同的结果。

- 模式：几乎所有的设计模式都是遵守开放-封闭原则的，我们见到的好设计，通常都经得起开放封闭原则的考验。不管是具体的各种设计 模式，还是更抽象的面向对象设计原则，比如单一职责原则、最少知识原则、依赖倒置原则等，都是为了让程序遵守开放封闭原则而出现的。可以这样说，开放-封闭原则是编写一个好程序的 目标，其他设计原则都是达到这个目标的过程。

    - 观察者模式：用来降低多个对象之间的依赖关系，它可以取代对象之间硬编码的通知机制， 一个对象不用再显式地调用另外一个对象的某个接口。当有新的订阅者出现时，发布者的代码不 需要进行任何修改;同样当发布者需要改变时，也不会影响到之前的订阅者。
    - 模板方法模式：在一个运用了模板方法模式的程序中，子类的方法种类和执行顺序都是不变的，所以 我们把这部分逻辑抽出来放到父类的模板方法里面;而子类的方法具体怎么实现则是可变的，于 是把这部分变化的逻辑封装到子类中。通过增加新的子类，便能给系统增加新的功能，并不需要 改动抽象父类以及其他的子类，这也是符合开放封闭原则的。
    - 策略模式：策略模式将各种算法都封装成单独的策略类，这些策略类可以被交换使用。策略和使用策略 的客户代码可以分别独立进行修改而互不影响。我们增加一个新的策略类也非常方便，完全不用修改之前的代码。
    - 责任链模式。。。

- 总结：实际上，让程序保持完全封闭是不容易做到的。就算技术上做得到，也需要花费太多的时间 和精力。而且让程序符合开放封闭原则的代价是引入更多的抽象层次，更多的抽象有可能会增大代码的复杂度。

    - **挑选出最容易发生变化的地方，然后构造抽象来封闭这些变化。**
    - **在不可避免发生修改的时候，尽量修改那些相对容易修改的地方。拿一个开源库来说，修改它提供的配置文件，总比修改它的源代码来得简单。**

## 设计模式

- 创造类

    - 单例模式
    - 工厂模式
    - 抽象工厂模式
    - 建造者模式
    - 原型模式

- 行为类

    - 迭代器模式
    - 命令模式
    - 解释器模式
    - 责任链模式
    - 观察者模式
    - 中介者模式
    - 备忘录模式
    - 状态模式
    - 策略模式
    - 模板方法模式
    - 访问者模式

- 结构类

    - 适配器模式
    - 组合模式
    - 代理模式
    - 桥梁模式
    - 装饰模式
    - 门面模式
    - 享元模式

## 实战敬仰

- 路由参数透传和埋点参数
- JSSDK 适配器
- redumd 模板方法模式
- react hoc
- dom 事件责任链


## 参考

书籍

- 《JavaScript 设计模式与实践》
- [《Dive Into Design Pattern》](https://refactoringguru.cn/design-patterns)

教程

- [JavaScript设计模式es6（23种)](https://juejin.cn/post/6844904032826294286#heading-5)
- [《JavaScript 设计模式与开发实践》读书笔记](https://github.com/JChehe/blog/issues/35)

---
