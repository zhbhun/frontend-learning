设计模式
========

## 定义

- > 人们在自己的环境中不断发现问题和寻找问题的解决方案的时候，发现一些问题及其解决方案不断变换面孔重复出现，但在这些不同的面孔后面有着共同的本质，这些共同的本质就是模式。
- ...

## 历史

- 1987 年，...
- 1991 年，...
- 1993 年，...
- 1995 年，"四人帮"（Gang of Four，或 GoF）发表了面向对象编程中使用模式化方法研究的开创性著作文献《Design Pattern》

## 原则

- 开闭原则

    > 在设计一个模式的时候，应当使这个模式可以在不被修改的前提下被扩展。

- 单一职责原则
- 里氏替换原则

    > 依赖抽象，不要依赖于具体

- 依赖倒置原则
- 接口隔离原则

    > 使用多个专门的接口比使用单一的总接口要好。

- 迪米特法则

    > 最少知识原则，一个对象应当对其他对象有尽可能少的了解。

- 合成复用原则

    > 在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，新的对象通过向这些对象的委派达到复用已有功能的目的。

## 模式

### 创建模式

- 简单工厂模式
- 工厂方法模式
- 抽象工厂模式
- 单例模式
- 多例模式
- 建造模式
- 原始模型模式

### 结构模式

- 适配器模式

    > 把一个类的接口变换成客户端所期待的另一种接口，从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作。

- 缺省适配模式

    > 为一个接口提供缺省实现，这样子类型可以从这个缺省实现进行扩展，而不必从原有接口进行扩展。

- 合成模式

    > 合成模式将对象组织到树结构中，可以用来描述整体与部分的关系。合成模式可以使客户端将单纯元素与复合元素同等看待

- 装饰模式

    > 以对客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。

- 代理模式

    > 给某一个对象提供一个代理对象，并由代理对象控制原对象的引用。

- 享元模式

    > 以共享的方式高效地支持大量的细粒度对象。

- 门面模式

    > 外部与一个子系统的通信必须通过一个统一的门面对象进行，这就是门面模式。

- 桥梁模式

### 行为模式

- 不变模式

    > 对象创建后就不再变化

- 策略模式

    > 针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以互相替换。

- 模板方法模式
- 观察者模式：发布-订阅模式，模式-视图模式，源-监听模式

    > 定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。

- 迭代子模式

    > 可以顺序地访问一个聚集中的元素而不必暴露聚集的内部对象。

- 责任链模式

    > 很多对象里每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配职责。

- 命令模式

    > 把一个请求或者操作封装到一个对象中，允许系统使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。

- 备忘录模式：快照模式

    > 备忘录对象是一个用来存储另外一个对象内部状态的快照对象。

- 状态模式

    > 允许一个对象在其内部状态改变的时候改变其行为。

- 访问者模式

    > 封装一些施加于某种数据结构元素之上的操作，一旦操作需要修改的话，接受这个操作的数据结构则可以保持不变。

- 解释器模式

    > 可以定义出其文法的一种表示，并同时提供一个解释器，客户端可以使用这个解释器来解释这个语言中的句子

- 调停者模式

    > 包装了一系列对象相互作用的方式，使得这些对象不必互相明显引用，从而使他们可以较松散的耦合。

## 应用

### 前端

> 我是如何进行一个项目架构的：划分源代码目录，生成构建输出目录和项目配置目录，源代码的组织结构通常是分层开发的，大致分为静态资源，公共组件，数据接口，工具库，页面路由和其他具体技术栈需要的的一些特殊目录，例如：express 有中间件目录等。各个层次的代码确定好对外输出的接口规则，实现接口的时候尽量保证遵从单一职责原则和最少知道原则，注意避免代码的重复拷贝。数据接口负责封装服务端接口，提供统一和规范的接口；公共组件实现页面上可重用的组件，新增一个组件时优先定义好该组件的职责和API。页面模块负责实现调用数据接口，利用公共组件渲染出对应路由的页面。在封装接口和维护的时候会用到适配器模式，装饰器模式。工具函数可能会利用带策略模式，例如前端动画的缓动函数。

> 现在流行的前端框架内部实现都实践了大量的设计模式，例如：Facebook 提供的不可变数据结构就实现了不变模式，flux 的 action 实现了命令模式，react 和 vue 等库实现了观察者模式，帮助开发者从dom操作中解放出来。

- 创建模式

    - 原始模型模式

        - JavaScript 基于原型链继承
        - Object.create

    - 工厂模式

        - React 组件实例就是工程模式，你只需要声明组件，组件的创建都有对应的工厂方法去实例化

- 结构模式

    - 适配器模式

        - RN 的缓存库实现，通过适配器将接口不同的存储 API 适配成统一的缓存接口

    - 缺省适配模式

        - ES6 参与默认值

    - 代理模式

        - Mock

- 行为模式

    - 不变模式：开发更加简单，可回朔，测试友好，减少了任何可能的副作用（缺点是更消耗内存）。

        - Immutable.js

    - 策略模式

        - 缓动函数

    - 观察者模式

        - react
        - redux

    - 迭代子模式

        - Array 上的方法
    
    - 责任链模式

        - redux 的中间件

    - 命令模式

        - redux 的 action
