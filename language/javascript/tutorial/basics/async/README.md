# 异步

## 同步 VS 异步

- 异步：所谓"异步"，简单说就是一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。

    ```
    请求数据 =》 其他任务 =》处理数据
    ```

- 同步：同步的执行方式是连续的，不能插入其他任务，所以在数据获取的这段时间，程序只能干等着。

    ```
    请求数据 =》等待... =》处理数据 =》其他任务
    ```

## 异步编程

> 异步编程的语法目标，就是怎样让它更像同步编程。

### 回调函数

JavaScript 语言对异步编程的实现，就是回调函 —— 就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。

ps：外部无法捕获回调函数内抛出的错误，只能作为回调函数的入参，例如：Node.js 回调函数的 error first。

### Promise

回调函数存在多重嵌套问题，Promise 就是为了解决这个问题提出的。

ps：Promise 的写法只是回调函数的改进，使用 then 方法以后，异步任务的两段执行看得更清楚了。

### Generator

"协程"（coroutine），意思是多个线程互相协作，完成异步任务。在类 Java 存在线上阻塞的语言上，通过协程可以让代码执行效率不高（不用协程的话，各个同步阻塞任务任务都得串行执行）。

```
1. 协程 A 开始执行。
2. 协程 A 执行到一半，进入暂停，执行权转移到协程 B。
3. （一段时间后）协程B交还执行权。
4. 协程A恢复执行。
```

Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用 yield 语句注明。

```js
function* gen(x){
  var y = yield x + 2;
  return y;
}
var g = gen(1);
g.next() // { value: 3, done: false }
g.next() // { value: undefined, done: true }
```

ps：上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器 ）g 。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针 g 的 next 方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的 yield 语句，上例是执行到 x + 2 为止。

总结：next 方法的作用是分阶段执行 Generator 函数。每次调用 next 方法，会返回一个对象，表示当前阶段的信息（ value 属性和 done 属性）。value 属性是 yield 语句后面表达式的值，表示当前阶段的值；done 属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。
