<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>多视频拼接播放器</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto,
          'Helvetica Neue', Arial, sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
      }

      .container {
        background: white;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        padding: 30px;
        max-width: 900px;
        width: 100%;
      }

      h1 {
        text-align: center;
        color: #333;
        margin-bottom: 30px;
        font-size: 28px;
      }

      .file-input-wrapper {
        margin-bottom: 30px;
        text-align: center;
      }

      .file-input-label {
        display: inline-block;
        padding: 12px 24px;
        background: #667eea;
        color: white;
        border-radius: 8px;
        cursor: pointer;
        transition: background 0.3s;
        font-size: 16px;
      }

      .file-input-label:hover {
        background: #5568d3;
      }

      input[type='file'] {
        display: none;
      }

      .video-list {
        margin-bottom: 20px;
        max-height: 200px;
        overflow-y: auto;
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        padding: 10px;
      }

      .video-item {
        padding: 8px;
        margin-bottom: 5px;
        background: #f5f5f5;
        border-radius: 4px;
        font-size: 14px;
        color: #666;
      }

      .video-item:last-child {
        margin-bottom: 0;
      }

      .video-wrapper {
        position: relative;
        margin: auto;
        width: 100%;
        max-width: 100%;
        max-height: 480px;
        background: transparent;
        border-radius: 8px;
        overflow: hidden;
        margin-bottom: 20px;
        min-height: 300px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      video {
        display: block;
        opacity: 0;
        pointer-events: none;
      }

      video.active {
        opacity: 1;
        z-index: 2;
      }

      video.preparing {
        opacity: 0;
        z-index: 1;
      }

      /* 视频按contain模式显示 */
      video.contain-video {
        width: 100%;
        height: 100%;
        object-fit: contain;
        position: absolute;
        top: 0;
        left: 0;
      }

      .controls {
        background: #f8f8f8;
        padding: 15px;
        border-radius: 8px;
      }

      .progress-container {
        width: 100%;
        height: 8px;
        background: #e0e0e0;
        border-radius: 4px;
        margin-bottom: 15px;
        cursor: pointer;
        position: relative;
      }

      .progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        border-radius: 4px;
        width: 0%;
        transition: width 0.1s;
      }

      .progress-time {
        display: flex;
        justify-content: space-between;
        font-size: 12px;
        color: #666;
        margin-bottom: 10px;
      }

      .button-group {
        display: flex;
        gap: 10px;
        justify-content: center;
      }

      button {
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        font-size: 16px;
        cursor: pointer;
        transition: all 0.3s;
        font-weight: 500;
      }

      .play-pause-btn {
        background: #667eea;
        color: white;
        min-width: 120px;
      }

      .play-pause-btn:hover {
        background: #5568d3;
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
      }

      .play-pause-btn:active {
        transform: translateY(0);
      }

      .info {
        text-align: center;
        color: #999;
        font-size: 14px;
        margin-top: 15px;
      }

      .hidden {
        display: none;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>多视频拼接播放器</h1>

      <div class="file-input-wrapper">
        <label for="videoInput" class="file-input-label">
          选择多个视频文件
        </label>
        <input type="file" id="videoInput" multiple accept="video/*" />
      </div>

      <div class="video-wrapper" id="videoWrapper">
        <!-- 视频元素将动态创建 -->
      </div>

      <div class="controls">
        <div class="progress-time">
          <span id="currentTime">00:00</span>
          <span id="totalTime">00:00</span>
        </div>
        <div class="progress-container" id="progressContainer">
          <div class="progress-bar" id="progressBar"></div>
        </div>
        <div class="button-group">
          <button class="play-pause-btn" id="playPauseBtn">播放</button>
        </div>
        <div class="info">
          <span id="videoInfo">请选择视频文件</span>
        </div>
      </div>
    </div>

    <script>
      const videoInput = document.getElementById('videoInput')
      const playPauseBtn = document.getElementById('playPauseBtn')
      const progressBar = document.getElementById('progressBar')
      const progressContainer = document.getElementById('progressContainer')
      const currentTimeSpan = document.getElementById('currentTime')
      const totalTimeSpan = document.getElementById('totalTime')
      const videoInfo = document.getElementById('videoInfo')
      const videoWrapper = document.querySelector('.video-wrapper')

      let videoFiles = [] // 存储视频 URL 字符串
      let videoDurations = [] // 存储每个视频的时长
      let totalDuration = 0
      let currentTime = 0
      let isPlaying = false
      let durationLoadPromises = [] // 存储加载时长的 Promise
      let progressAnimationId = null // 进度条动画ID
      let lastProgressTime = 0 // 上次进度更新时间
      let progressVelocity = 0 // 进度变化速度（用于平滑过渡）
      let firstVideoLoaded = false // 标记第一个视频是否已加载
      let containerWidth = 0 // 容器宽度（基于第一个视频）
      let containerHeight = 0 // 容器高度（基于第一个视频）

      // 视频元素数组
      let videoElements = [] // 存储所有视频元素
      let currentVideoIndex = 0 // 当前播放的视频索引
      let preloadTriggered = false // 标记是否已触发预加载

      // AudioContext 相关变量
      let audioContext = null
      let audioSourceNodes = [] // 存储每个音频源的节点
      let audioGainNode = null
      let isAudioContextInitialized = false
      let audioVideoElements = [] // 存储每个视频对应的音频 video element



      // 初始化 AudioContext
      async function initAudioContext() {
        if (isAudioContextInitialized) {
          return
        }

        try {
          // 创建 AudioContext
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)()

          // 创建 GainNode 用于控制音量
          audioGainNode = audioContext.createGain()
          audioGainNode.gain.value = 1.0 // 设置音量为 100%
          audioGainNode.connect(audioContext.destination)

          isAudioContextInitialized = true
        } catch (error) {
          console.error('初始化 AudioContext 失败:', error)
        }
      }

      // 连接音频源到 AudioContext
      function connectAudioSource(videoElement, index) {
        if (!audioContext || !videoElement) {
          return
        }

        // 如果该索引已有音频源，说明已经连接过，不需要再次连接
        if (audioSourceNodes[index]) {
          return
        }

        try {
          // 创建新的音频源节点
          const sourceNode = audioContext.createMediaElementSource(videoElement)
          sourceNode.connect(audioGainNode)
          audioSourceNodes[index] = sourceNode

          // 如果 AudioContext 处于 suspended 状态，恢复它
          if (audioContext.state === 'suspended') {
            audioContext.resume()
          }
        } catch (error) {
          // 如果已经连接过，忽略错误（可能之前连接过但记录丢失了）
          if (
            error.name === 'InvalidStateError' &&
            error.message.includes('already connected')
          ) {
            console.warn(`音频源 ${index} 已经连接过，跳过重复连接`)
          } else {
            console.error('连接音频源失败:', error)
          }
        }
      }

      // 断开指定索引的音频源
      function disconnectAudioSource(index) {
        if (audioSourceNodes[index]) {
          audioSourceNodes[index].disconnect()
          audioSourceNodes[index] = null
        }
      }

      // 获取当前活动的视频元素
      function getActiveVideo() {
        return videoElements[currentVideoIndex] || null
      }

      // 创建视频元素
      function createVideoElements(urls) {
        // 清除现有的视频元素和音频元素
        videoElements.forEach((video) => {
          if (video.parentNode) {
            video.parentNode.removeChild(video)
          }
        })
        videoElements = []

        audioVideoElements.forEach((audioVideo, index) => {
          if (audioVideo && audioVideo.parentNode) {
            audioVideo.parentNode.removeChild(audioVideo)
          }
          // 断开音频源连接
          disconnectAudioSource(index)
        })
        audioVideoElements = []
        audioSourceNodes = []

        // 创建新的视频元素和对应的音频元素
        for (let i = 0; i < urls.length; i++) {
          const video = document.createElement('video')
          video.src = urls[i]
          video.muted = true
          video.preload = "auto"
          video.classList.add('preparing')
          video.classList.add('contain-video')
          videoWrapper.appendChild(video)
          videoElements.push(video)

          // 创建对应的音频 video element
          let audioVideo = audioVideoElements[i]
          if (!audioVideo) {
            // 创建新的 video element 用于音频提取
            audioVideo = document.createElement('video')
            audioVideo.style.display = 'none'
            audioVideo.muted = false // 音频 video 不静音，用于提取音频
            document.body.appendChild(audioVideo)
            audioVideoElements[i] = audioVideo
          }
          audioVideo.src = urls[i]
          audioVideo.preload = "auto"

          // 初始化 AudioContext 并连接音频源
          initAudioContext().then(() => {
            audioVideo.addEventListener(
              'loadedmetadata',
              () => {
                connectAudioSource(audioVideo, i)
              },
              { once: true }
            )
          })

          // 如果是第一个视频，设置容器大小（基于第一个视频的分辨率比例）
          if (i === 0) {
            video.addEventListener(
              'loadedmetadata',
              () => {
                const videoWidth = video.videoWidth
                const videoHeight = video.videoHeight

                if (videoWidth > 0 && videoHeight > 0) {
                  // 计算合适的显示尺寸（保持第一个视频的宽高比，同时考虑最大宽度和最大高度限制）
                  const maxContainerHeight = 480 // 最大高度
                  const parentMaxWidth =
                    videoWrapper.parentElement.clientWidth || 900
                  const aspectRatio = videoWidth / videoHeight // 使用第一个视频的宽高比

                  // 先按最大高度计算，确保不超过最大高度
                  let displayHeight = Math.min(videoHeight, maxContainerHeight)
                  let displayWidth = displayHeight * aspectRatio

                  // 如果宽度超过父容器宽度，按宽度重新计算
                  if (displayWidth > parentMaxWidth) {
                    displayWidth = parentMaxWidth
                    displayHeight = displayWidth / aspectRatio
                  }

                  // 设置容器大小（固定为第一个视频的宽高比）
                  containerWidth = displayWidth
                  containerHeight = displayHeight
                  videoWrapper.style.width = displayWidth + 'px'
                  videoWrapper.style.height = displayHeight + 'px'
                  videoWrapper.style.minHeight = displayHeight + 'px'
                  videoWrapper.style.maxWidth = '100%'
                  videoWrapper.style.maxHeight = maxContainerHeight + 'px'
                  videoWrapper.style.aspectRatio = `${videoWidth} / ${videoHeight}` // 设置宽高比

                  firstVideoLoaded = true
                }
              },
              { once: true }
            )
          }
        }

        // 为所有视频元素绑定事件监听器
        setupActiveVideoEvents()
      }

      // 切换显示的视频
      function switchToVideo(index) {
        if (index < 0 || index >= videoElements.length) {
          return
        }

        // 隐藏所有视频
        videoElements.forEach((video) => {
          video.classList.remove('active')
          video.classList.add('preparing')
          // 所有节点都使用 contain 模式
          video.classList.add('contain-video')
        })

        // 显示当前视频
        const currentVideo = videoElements[index]
        currentVideo.classList.remove('preparing')
        currentVideo.classList.add('active')

        // 更新当前视频索引
        currentVideoIndex = index
      }

      // 同步音频视频时间
      function syncAudioVideo() {
        const activeVideo = getActiveVideo()
        const activeAudioVideo = audioVideoElements[currentVideoIndex]
        if (activeAudioVideo && activeVideo) {
          // 同步播放时间
          if (
            Math.abs(activeAudioVideo.currentTime - activeVideo.currentTime) >
            0.1
          ) {
            activeAudioVideo.currentTime = activeVideo.currentTime
          }
        }
      }

      // 获取当前活动的音频 video element
      function getActiveAudioVideo() {
        return audioVideoElements[currentVideoIndex] || null
      }

      // 格式化时间
      function formatTime(seconds) {
        const mins = Math.floor(seconds / 60)
        const secs = Math.floor(seconds % 60)
        return `${String(mins).padStart(2, '0')}:${String(secs).padStart(
          2,
          '0'
        )}`
      }

      // 获取视频时长
      function getVideoDuration(videoUrl) {
        return new Promise((resolve) => {
          const video = document.createElement('video')
          video.preload = 'metadata'
          video.src = videoUrl
          video.addEventListener('loadedmetadata', () => {
            const duration = video.duration
            resolve(duration)
          })
          video.addEventListener('error', () => {
            resolve(0)
          })
        })
      }

      // 计算总时长
      async function calculateTotalDuration() {
        totalDuration = 0
        videoDurations = []
        durationLoadPromises = []

        for (let i = 0; i < videoFiles.length; i++) {
          const promise = getVideoDuration(videoFiles[i])
          durationLoadPromises.push(promise)
          const duration = await promise
          videoDurations[i] = duration
          totalDuration += duration
        }

        updateTotalTime()
      }

      // 更新总时长显示
      function updateTotalTime() {
        totalTimeSpan.textContent = formatTime(totalDuration)
      }

      // 计算已播放的总时间
      function getTotalElapsedTime() {
        let elapsed = 0

        // 累加已播放完的视频时长
        for (let i = 0; i < currentVideoIndex; i++) {
          if (videoDurations[i]) {
            elapsed += videoDurations[i]
          }
        }

        // 加上当前视频的播放时间
        const activeVideo = getActiveVideo()
        if (activeVideo && activeVideo.src && activeVideo.duration) {
          elapsed += activeVideo.currentTime
        }

        return elapsed
      }

      // 平滑更新进度条
      function smoothUpdateProgress() {
        const activeVideo = getActiveVideo()
        if (!activeVideo || !activeVideo.src || totalDuration === 0) {
          if (progressAnimationId) {
            cancelAnimationFrame(progressAnimationId)
            progressAnimationId = null
          }
          return
        }

        const totalElapsed = getTotalElapsedTime()
        const progress = (totalElapsed / totalDuration) * 100
        const now = performance.now()

        // 计算进度变化速度（用于平滑过渡）
        if (lastProgressTime > 0) {
          const deltaTime = (now - lastProgressTime) / 1000 // 转换为秒
          const deltaProgress =
            progress - parseFloat(progressBar.style.width) || 0
          if (deltaTime > 0) {
            progressVelocity = deltaProgress / deltaTime
          }
        }

        lastProgressTime = now

        // 平滑更新进度条（使用缓动）
        const currentProgress = parseFloat(progressBar.style.width) || 0
        const targetProgress = Math.min(progress, 100)
        const diff = targetProgress - currentProgress

        // 如果差异很小，直接设置；否则平滑过渡
        if (Math.abs(diff) < 0.05) {
          progressBar.style.width = targetProgress + '%'
        } else {
          // 使用缓动函数平滑过渡，缓动系数根据差异大小动态调整
          const easing = Math.min(0.3, Math.abs(diff) * 0.1) // 差异越大，缓动越快
          const newProgress = currentProgress + diff * easing
          progressBar.style.width = newProgress + '%'
        }

        currentTime = totalElapsed
        currentTimeSpan.textContent = formatTime(totalElapsed)

        // 继续动画（即使视频暂停，也要继续更新以保持平滑）
        progressAnimationId = requestAnimationFrame(smoothUpdateProgress)
      }

      // 更新进度条（兼容旧接口）
      function updateProgress() {
        // 如果动画还没启动，启动它
        if (!progressAnimationId) {
          lastProgressTime = 0
          smoothUpdateProgress()
        }
      }

      // 停止进度条动画
      function stopProgressAnimation() {
        if (progressAnimationId) {
          cancelAnimationFrame(progressAnimationId)
          progressAnimationId = null
        }
      }

      // 切换到下一个视频
      function switchToNextVideo() {
        if (currentVideoIndex + 1 >= videoFiles.length) {
          // 所有视频播放完毕
          isPlaying = false
          playPauseBtn.textContent = '播放'
          const activeVideo = getActiveVideo()
          if (activeVideo) {
            activeVideo.pause()
          }
          const activeAudioVideo = getActiveAudioVideo()
          if (activeAudioVideo) {
            activeAudioVideo.pause()
          }
          // 更新进度条到100%
          if (totalDuration > 0) {
            progressBar.style.width = '100%'
            currentTimeSpan.textContent = formatTime(totalDuration)
          }
          return
        }

        const wasPlaying = isPlaying
        const oldActiveVideo = getActiveVideo()
        const oldActiveAudioVideo = getActiveAudioVideo()

        // 暂停当前视频和音频
        if (oldActiveVideo) {
          oldActiveVideo.pause()
        }
        if (oldActiveAudioVideo) {
          oldActiveAudioVideo.pause()
        }

        // 切换到下一个视频
        currentVideoIndex++
        switchToVideo(currentVideoIndex)

        const newActiveVideo = getActiveVideo()
        const newActiveAudioVideo = getActiveAudioVideo()
        const videoUrl = videoFiles[currentVideoIndex]
        videoInfo.textContent = `${currentVideoIndex + 1}/${videoFiles.length}`

        // 如果音频 video element 还没加载，加载它
        if (newActiveAudioVideo && !newActiveAudioVideo.src) {
          newActiveAudioVideo.src = videoUrl
          newActiveAudioVideo.muted = false
          newActiveAudioVideo.currentTime = 0
          newActiveAudioVideo.load()

          // 初始化 AudioContext 并连接新的音频源
          initAudioContext().then(() => {
            newActiveAudioVideo.addEventListener(
              'loadedmetadata',
              () => {
                connectAudioSource(newActiveAudioVideo, currentVideoIndex)
                // 确保音频进度重置为第0帧
                newActiveAudioVideo.currentTime = 0
              },
              { once: true }
            )
          })
        } else if (newActiveAudioVideo) {
          // 如果音频已经加载，也要重置进度为第0帧
          newActiveAudioVideo.currentTime = 0
        }

        // 如果之前是播放状态，开始播放新视频和音频
        if (wasPlaying) {
          if (newActiveVideo) {
            // 确保进度为0，直接播放
            newActiveVideo.currentTime = 0
            newActiveVideo.play().catch((error) => {
              console.warn('视频播放失败:', error)
            })
          }
          if (newActiveAudioVideo) {
            // 确保进度为0，直接播放
            newActiveAudioVideo.currentTime = 0
            newActiveAudioVideo
              .play()
              .then(() => {
                syncAudioVideo()
              })
              .catch((error) => {
                console.warn('音频播放失败:', error)
              })
          }
        }

        // 预加载逻辑已在 timeupdate 事件中处理（播放到50%时预加载）

        lastProgressTime = 0
        updateProgress()
      }

      // 播放/暂停
      function togglePlayPause() {
        if (videoFiles.length === 0) {
          alert('请先选择视频文件')
          return
        }

        const activeVideo = getActiveVideo()
        if (!activeVideo) {
          return
        }

        const activeAudioVideo = getActiveAudioVideo()
        if (!activeAudioVideo) {
          return
        }

        if (isPlaying) {
          // 暂停所有音频视频元素，确保没有遗漏
          audioVideoElements.forEach((audioVideo) => {
            if (audioVideo && !audioVideo.paused) {
              audioVideo.pause()
            }
          })

          // 暂停当前视频
          if (!activeVideo.paused) {
            activeVideo.pause()
          }

          playPauseBtn.textContent = '播放'
          isPlaying = false
          // 暂停时停止进度条动画（但保持当前进度显示）
        } else {
          // 确保 AudioContext 在用户交互时恢复
          if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume()
          }

          // 先暂停所有其他音频视频元素
          audioVideoElements.forEach((audioVideo, index) => {
            if (audioVideo && index !== currentVideoIndex && !audioVideo.paused) {
              audioVideo.pause()
            }
          })

          // 同步播放视频和音频
          const playPromise = activeVideo.play().catch((error) => {
            console.warn('视频播放失败:', error)
            return Promise.reject(error)
          })

          const audioPlayPromise = activeAudioVideo
            ? activeAudioVideo.play().catch((error) => {
                // 如果音频播放失败，忽略错误（可能因为用户交互策略）
                console.warn('音频播放失败:', error)
              })
            : Promise.resolve()

          Promise.all([playPromise, audioPlayPromise])
            .then(() => {
              syncAudioVideo() // 同步时间
              playPauseBtn.textContent = '暂停'
              isPlaying = true
              // 播放时启动进度条动画
              lastProgressTime = 0
              updateProgress()
            })
            .catch(() => {
              // 如果播放失败，重置状态
              isPlaying = false
              playPauseBtn.textContent = '播放'
            })
        }
      }

      // 点击进度条跳转
      function seekTo(event) {
        if (totalDuration === 0) return

        const activeVideo = getActiveVideo()
        if (!activeVideo || !activeVideo.src) {
          return
        }

        const rect = progressContainer.getBoundingClientRect()
        const clickX = event.clientX - rect.left
        const percentage = Math.max(0, Math.min(1, clickX / rect.width))
        const targetTotalTime = percentage * totalDuration

        // 找到目标时间对应的视频索引
        let accumulatedTime = 0
        let targetVideoIndex = 0
        let targetVideoTime = 0

        for (let i = 0; i < videoDurations.length; i++) {
          if (accumulatedTime + videoDurations[i] >= targetTotalTime) {
            targetVideoIndex = i
            targetVideoTime = targetTotalTime - accumulatedTime
            break
          }
          accumulatedTime += videoDurations[i]
        }

        // 如果目标视频不是当前视频，需要切换视频
        if (targetVideoIndex !== currentVideoIndex) {
          const wasPlaying = isPlaying

          // 先暂停所有音频视频
          const oldActiveVideo = getActiveVideo()
          const oldActiveAudioVideo = getActiveAudioVideo()
          if (oldActiveVideo && !oldActiveVideo.paused) {
            oldActiveVideo.pause()
          }
          if (oldActiveAudioVideo && !oldActiveAudioVideo.paused) {
            oldActiveAudioVideo.pause()
          }

          // 切换到目标视频
          currentVideoIndex = targetVideoIndex
          preloadTriggered = false
          switchToVideo(targetVideoIndex)
          videoInfo.textContent = `${targetVideoIndex + 1}/${videoFiles.length}`
          updateProgress()

          const targetVideoElement = videoElements[targetVideoIndex]
          const targetAudioVideo = audioVideoElements[targetVideoIndex]

          if (targetVideoElement) {
            // 等待视频和音频都加载完成后再设置时间和播放
            const setupSeek = () => {
              const targetTime = Math.max(
                0,
                Math.min(targetVideoTime, targetVideoElement.duration)
              )
              targetVideoElement.currentTime = targetTime

              // 同步音频时间
              if (targetAudioVideo) {
                // 确保音频 video element 已经加载
                if (targetAudioVideo.readyState >= 2) {
                  // HAVE_CURRENT_DATA
                  targetAudioVideo.currentTime = targetTime
                } else {
                  // 如果还没加载，等待加载完成
                  targetAudioVideo.addEventListener(
                    'loadeddata',
                    () => {
                      targetAudioVideo.currentTime = targetTime
                    },
                    { once: true }
                  )
                }
              }

              if (wasPlaying) {
                targetVideoElement.play().catch((error) => {
                  console.warn('视频播放失败:', error)
                })
                if (targetAudioVideo) {
                  targetAudioVideo
                    .play()
                    .then(() => {
                      syncAudioVideo()
                    })
                    .catch((error) => {
                      console.warn('音频播放失败:', error)
                    })
                }
              } else {
                // 确保暂停状态
                if (!targetVideoElement.paused) {
                  targetVideoElement.pause()
                }
                if (targetAudioVideo && !targetAudioVideo.paused) {
                  targetAudioVideo.pause()
                }
              }
            }

            // 如果视频已经加载，直接设置；否则等待加载
            if (targetVideoElement.readyState >= 2) {
              setupSeek()
            } else {
              targetVideoElement.addEventListener('loadedmetadata', setupSeek, {
                once: true,
              })
            }
          }
        } else {
          // 设置播放位置（同一视频内跳转）
          const targetTime = Math.max(
            0,
            Math.min(targetVideoTime, activeVideo.duration)
          )
          activeVideo.currentTime = targetTime

          // 同步音频时间
          const activeAudioVideo = getActiveAudioVideo()
          if (activeAudioVideo) {
            // 确保音频 video element 已经加载
            if (activeAudioVideo.readyState >= 2) {
              activeAudioVideo.currentTime = targetTime
            } else {
              // 如果还没加载，等待加载完成
              activeAudioVideo.addEventListener(
                'loadeddata',
                () => {
                  activeAudioVideo.currentTime = targetTime
                },
                { once: true }
              )
            }
          }
        }
      }

      // 事件监听
      videoInput.addEventListener('change', (e) => {
        const files = Array.from(e.target.files)
        // 将 File 对象转换为 URL
        videoFiles = files.map((file) => URL.createObjectURL(file))

        if (videoFiles.length === 0) {
          videoInfo.textContent = '请选择视频文件'
          createVideoElements([])
          return
        }

        // 重置标志和容器大小
        firstVideoLoaded = false
        currentVideoIndex = 0
        videoWrapper.style.width = '100%'
        videoWrapper.style.height = 'auto'
        videoWrapper.style.minHeight = '300px'
        videoWrapper.style.maxWidth = '100%'
        videoWrapper.style.maxHeight = '480px'
        videoWrapper.style.aspectRatio = 'auto' // 重置宽高比

        // 创建对应数量的视频元素，传入 URL 数组
        createVideoElements(videoFiles)

        // 初始化第一个视频
        currentVideoIndex = 0
        preloadTriggered = false
        switchToVideo(0)
        videoInfo.textContent = `1/${videoFiles.length}`
        updateProgress()

        calculateTotalDuration()
      })

      // 初始化默认视频
      function initDefaultVideos() {
        videoFiles = new URLSearchParams(location.search).get('videos')?.split(',')

        // 重置标志和容器大小
        firstVideoLoaded = false
        currentVideoIndex = 0
        videoWrapper.style.width = '100%'
        videoWrapper.style.height = 'auto'
        videoWrapper.style.minHeight = '300px'
        videoWrapper.style.maxWidth = '100%'
        videoWrapper.style.maxHeight = '480px'
        videoWrapper.style.aspectRatio = 'auto'

        // 创建对应数量的视频元素，传入 URL 数组
        createVideoElements(videoFiles)

        // 初始化第一个视频
        currentVideoIndex = 0
        preloadTriggered = false
        switchToVideo(0)
        videoInfo.textContent = `1/${videoFiles.length}`
        updateProgress()

        calculateTotalDuration()
      }

      // 页面加载时初始化默认视频
      initDefaultVideos()

      // 在页面加载时预初始化 AudioContext（但不会真正启动，直到用户交互）
      initAudioContext()

      playPauseBtn.addEventListener('click', togglePlayPause)

      progressContainer.addEventListener('click', seekTo)

      // 为所有视频元素绑定事件监听器（一开始就绑定，根据是否 active 来决定是否处理）
      function setupActiveVideoEvents() {
        // 检查视频元素是否已创建
        if (videoElements.length === 0) {
          return
        }

        // 为所有视频元素绑定事件监听器
        videoElements.forEach((video, index) => {
          // 如果已经绑定过事件，先移除（避免重复绑定）
          if (video._hasEventsBound) {
            return
          }

          // timeupdate 事件处理
          const handleTimeupdate = (event) => {
            const targetVideo = event.target
            // 只处理 active 视频的事件
            if (!targetVideo.classList.contains('active')) {
              return
            }

            // timeupdate事件只用于触发预加载和切换逻辑
            // 进度条更新由requestAnimationFrame处理，更平滑

            // 同步音频视频时间（定期同步，确保不会偏差太大）
            syncAudioVideo()

            // 在当前视频播放到50%时，开始预加载下一个视频（更早准备）
            if (
              !preloadTriggered &&
              targetVideo &&
              targetVideo.duration &&
              targetVideo.currentTime > 0
            ) {
              const progress = targetVideo.currentTime / targetVideo.duration
              if (
                progress >= 0.5 &&
                currentVideoIndex + 1 < videoFiles.length
              ) {
                const nextVideoElement = videoElements[currentVideoIndex + 1]
                if (nextVideoElement && !nextVideoElement.src) {
                  nextVideoElement.src = videoFiles[currentVideoIndex + 1]
                  nextVideoElement.currentTime = 0
                }
                preloadTriggered = true
              }
            }
          }

          // ended 事件处理
          const handleEnded = (event) => {
            const targetVideo = event.target
            // 只处理 active 视频的事件
            if (!targetVideo.classList.contains('active')) {
              return
            }

            // 当前视频播放完毕，切换到下一个
            if (currentVideoIndex + 1 < videoFiles.length) {
              switchToNextVideo()
            } else {
              // 所有视频播放完毕
              isPlaying = false
              playPauseBtn.textContent = '播放'
              if (totalDuration > 0) {
                progressBar.style.width = '100%'
                currentTimeSpan.textContent = formatTime(totalDuration)
              }
            }
          }

          // play 事件处理
          const handlePlay = (event) => {
            const targetVideo = event.target
            // 只处理 active 视频的事件
            if (!targetVideo.classList.contains('active')) {
              return
            }

            // 视频开始播放时，启动进度条动画
            if (!progressAnimationId) {
              lastProgressTime = 0
              smoothUpdateProgress()
            }
          }

          // pause 事件处理
          const handlePause = (event) => {
            const targetVideo = event.target
            // 只处理 active 视频的事件
            if (!targetVideo.classList.contains('active')) {
              return
            }

            // 视频暂停时，进度条动画会继续运行但会显示当前进度
            // 不需要停止动画，让它平滑停止在当前位置
          }

          // loadedmetadata 事件处理
          const handleLoadedmetadata = (event) => {
            const targetVideo = event.target
            // 只处理 active 视频的事件
            if (!targetVideo.classList.contains('active')) {
              return
            }

            // 总时长已经在 calculateTotalDuration 中更新
            updateProgress()
          }

          // 绑定事件监听器
          video.addEventListener('timeupdate', handleTimeupdate)
          video.addEventListener('ended', handleEnded)
          video.addEventListener('play', handlePlay)
          video.addEventListener('pause', handlePause)
          video.addEventListener('loadedmetadata', handleLoadedmetadata)

          // 标记已绑定事件
          video._hasEventsBound = true
        })
      }
    </script>
  </body>
</html>
