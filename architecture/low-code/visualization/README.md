# 页面可视化搭建

## 名词术语

- UIDL：用于描述搭建页面时的所有与 UI 相关的可结构化信息。
  
  - UIDL 元信息
  
  - 项目元信息
  
  - 页面 DSL 规范
  
  - 使用的物料以及物料的配置
    
    参考 https://docs.teleporthq.io/guides/what-is-this.html#uidl

- DSL：用于描述搭建页面时渲染页面结构的 DSL，为树状结构，每个节点都是一个组件实例
- BOM：是 DSL 的编程接口，提供了对 DSL 的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变 DSL 的结构，样式和内容。
- 组件：组件时组成页面的基本单元，从使用场景触发，组件可分为两种：通用组件和业务组件
- 物料：搭建页面时所需的组件、图片、视频、字体和文档等一系列可丰富页面功能、样式的实体
- 画布：物料使用、编辑和渲染等一系列有关搭建工作的模块
- 设置器：配置组件相关属性的面板，通常包含：样式、属性、动作和动画
- 编辑器：包含了组件、物料、画布、设置器、图层等模块，用于搭建页面生成 DSL 的工作台
- 生成器：基于 DSL 生成搭建后的页面，根据物料的使用形式分为两种：

  - 运行时生产：搭建的页面会将物料的 bundle 拼接在一起，拼接后页面能做到独立运行
    
    - 优点：可以快速的发布预览
    - 缺点：生产的页面形态需要动态加载组件，会导致页面性能较差
  
  - 源码生产：会将物料下载安装的本地，并生成入口文件，再经历打包发布生成出页面
    
    - 优点：对生产的页面形态无要求，页面性能高
    - 缺点：产出页面需要经历打包、发布，无法快速的发布预览，影响用户体验

## 技术要点

- [如何抽象可视化搭建](https://github.com/ascoders/weekly/blob/master/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%90%AD%E5%BB%BA/268.%E5%A6%82%E4%BD%95%E6%8A%BD%E8%B1%A1%E5%8F%AF%E8%A7%86%E5%8C%96%E6%90%AD%E5%BB%BA.md)

### DSL

存在问题：

1. 如何解决 DSL 版本兼容问题
2. 如何解决数据膨胀问题
   一个站点可能存在多个页面，如果数据较多，每次都要全量保存和下发，比较影响性能。
3. ...

### BOM

BOM：Batman Object Model，是 DSL 的编程接口，提供了对 DSL 的结构化的表述，并定义了一种方式可以使从程序中对该结构进行访问，从而改变 DSL 的结构，样式和内容。

#### 生命周期

- node: beforeCreate => create => created => insertion =》 mounted =》unmounted
- ...

参考

- 小程序：onLoad =》onShow =》onReady =》onHide =》onShow =》onUnload
- vue：beforeCreate =》created =》beforeMount =》 mount =》 beforeUpdate =》 updated =》 beforeDestroy =》 destroy

### 画布

#### 编辑器和预览样式隔离

- div

    - 优点：实现简单
    - 缺点：样式没有隔离，预览样式容易被编辑器影响；无法实现固定定位（可以通过 transform:scale(1) 来处理）；不支持媒体查询实现响应式样式。

- Shadow DOM

    - 优点：在 div 基础上解决了样式隔离问题
    - 缺点：同样存在固定定位和不支持媒体查询问题，并且需要将预览样式单独引入到 Shadow DOM 中。

- iframe

    - 优点：解决了样式隔离、固定定位和媒体查询问题
    - 缺点：要解决如何在 iframe 中渲染预览样式

        1. 直接拿到 iframe 内的根元素，然后渲染在该节点上

            - 优点：这种方式的预览样式加载很快，不会出现闪烁的问题
            - 缺点：组件使用的样式需要引入到 iframe 中，而且因为 JS 是没有隔离的，会导致类似 Modal 的组件会渲染到编辑器所在的页面上。

        2. iframe src 加载方式

            - 优点：实现简单，CSS 和 JS 都是隔离的
            - 缺点：加载稍微慢一点。

#### 编辑渲染分层

用户搭建时需要在组件上渲染出各种编辑交互态，这些状态不能直接与组件本身耦合。此外，组件本身时可交互的，如何在画布编辑时避免触发组件自身的交互行为呢？

- 组件包装 + 事件捕获
  
  - 存在组件嵌套的时候，需要判定到底是与子组件交互还是父组件，实现起来较为困难和复杂。
  - 无法解决包装组件层级较低问题，导致画布编辑控件显示和交互出现问题；

- 组件包装 + css point-events
  
  - 如果业务组件里有使用 point-events，仍然可能会与组件产生交互
  - 同样无法解决包装组件层级较低问题；

- 编辑渲染分层：
  
    把画布分为渲染层与编辑层，彼此之间通过通信协议进行解耦，渲染层负责真实组件的渲染，编辑层则是在渲染层之上的一层蒙版，其中蒙版是由与真实元素相同大小定位的虚拟元素组成的。当用户编辑页面时，只能操作编辑层上的元素。
  
  - 画布编辑交互状态的实现与组件本身解耦；
  
  - 通过蒙层屏蔽了组件自身的交互行为；
  
  - 可以比较容易解决编辑模式的高亮线框和控制器的层级问题（不会因为嵌套组件被其他组件折叠时，编辑交互辅助显示被遮挡问题）。
    
    问题：但是蒙层模式比较难以解决嵌套组件存在变形样式的模拟问题，例如遇到目标组件父级存在旋转时，蒙层中的镜像节点难以模拟。虽然可以在蒙层模拟渲染各个层，但是遇到一些定制组件时，还是会存在问题。

- 基于 iframe 的编辑渲染分层
  
    渲染层得力于 iframe 的天然隔离性，画布编辑器中的所有逻辑、样式不会影响渲染层本身，而且组件可以支持媒体查询适配不同大小的屏幕，从而实现响应式组件。

#### 滚动模式

内部滚动 vs 外部滚动

- 内部滚动：在 tmagic 中出现，编辑体验较差，但可以较为真实的模拟设备，实现固定定位效果较为容易
- 外部滚动：大部分采用该方案，编辑交互体验较好，但在实现固定定位等需要模拟真实设备的场景时较为麻烦

#### 缩放模式

整体放大 VS 单独组件放大

- 整体放大：易企秀、tmagic 等，实现较为简单，但需要解决可视化控制器（拖拽和放大等元素）的跟随放大问题
  ps：tmagic 组件画布使用 transform scale 缩放，拖拽和放大缩小器放在蒙层处理。
- 单独组件放大：稿定设计等，避免可视化控制器跟随放大，但实现较为麻烦，而且嵌套子组件也会跟随放大，无法解决嵌套子组件的放大问题

#### 元素封装

在实现元素选择、拖拽时需要能够标识出对应的元素节点，以及在实现元素动作和动画配置时，也需要能够将事件绑定元素上。

- 组件支持透传参数：如果想为组件绑定事件，需要在组件开发时进行内部的 props 消费，如把 onClick 透传到组件根节点上，但针对组件产物进行事件绑定。
  
  - 优点：没有多余的包装元素
  - 缺点：编辑器的行为侵入组件源代码，组件实现时得严格遵循规范，支持属性透传到根节点上。

    ps：有些第三方组件可能无法通过 ref 拿到 DOM 元素，这时可以采取的办法：1、通过元素 id 来查询获取对应的 DOM 元素;2、嵌入隐藏元素的 parentElement 来获取；3、提供自定义的扩展方法来查询获取 DOM 元素；4、添加额外的包装元素(见下文)；

- 元素增加一层包装节点 Wrapper：在 Wapper 中添加组件元素标识，并为每个组件绑定事件。
  
  - 优点：实现简单，组件源代码只要做好自己的事情，不需要关心编辑器的行为
  
  - 缺点：组件多包装了一层节点，需要解决包装层节点对组件元素定位和布局的影响。
    
    ps：可借助 `display:contents` 可以实现幽灵节点，参考 [冷知识！使用 display: contents 实现幽灵节点？](https://mp.weixin.qq.com/s?__biz=Mzg4MTYwMzY1Mw==&mid=2247502962&idx=1&sn=f99286f0a6c9c4adb481ed1b3785ec65&scene=21#wechat_redirect)

#### 元素选择

画布采用编辑渲染分层的方案，需要实现透过蒙层选中目标节点。主要思路是绑定全局的事件，再根据点击的位置找到相应的元素，进行分发。通过调用 document.elementsFromPoint 方法，该方法会返回鼠标下的所有 DOM 节点，后续可深度遍历查找出当前鼠标选中的画布元素。

- 优点：节省内存
- 缺点：需要一套完善的组件查找机制

#### 元素拖拽

事件机制

- Mouse：可定制型较强
- Drag：镜像组件比较不好实现

实现思路

- 拖拽开始
  
  - 拖拽行为判定
  - 添加时生成镜像组件

- 拖拽中
  
  - 拖拽方向、距离和位置计算
  
  - 拖拽吸附和辅助线：位置吸附、间距吸附、大小吸附
  
  - 拖拽放置提示：高亮父节点，高亮放置位置
    
    - 自由布局：高亮父节点
    - 流式布局：高亮父节点 + 放置位置
  
  - 拖拽到边界时容器随之滚动
  
  - 拖拽后调整父容器的行为
  
  - 流式布局的拖拽位置计算

- 拖拽结束
  
  - 生成 DSL 数据，插入到对应的节点中
  - 自动选中拖拽的元素

开源库

- moveable
- dragable

#### 元素旋转

组件旋转功能常见于设计工具或自由度较高的建站平台中，活动页搭建平台中使用的场景较少。旋转功能的具体原理简单来说是，拿到鼠标点击时坐标与鼠标移动时坐标针对组件中心点各自对应的角度，将其相减就是旋转的角度。

但是在嵌套元素旋转后，会遇到编辑层要如何计算子元素的旋转角度，流式布局要如何计算位置等问题？

#### 复制黏贴

- 黏贴元素的识别（剪贴板的内容可能来自其他平台）
- 复制数据的跨浏览器使用（需要解决不同浏览器能够共用自定义格式和兼容性问题）
- 黏贴元素的 ID 需要去重生成
- 黏贴元素需要重置组件的位置信息，避免出现偏移不符合目标容器的情况。

#### 文本编辑

在很多搭建平台、设计工具中，文本内容可以进行双击编辑，使用起来符合直觉。

TODO

#### 选择区域/多选组件

用户在画布上拖拽鼠标时需实时高亮已选择的区域，该功能属于组件多选的基本能力。

- 快捷键支持多选；

- 选择区域计算命中组件；

- 多选组件的画布拖拽

- 多选组件的属性配置操作；

- 多选组件中出现混合布局方式该怎么处理，如一些组件时自由定位的，一些组件是流式布局的子元素。
  
    参考 figam，以多选拖拽的起点起点为准，如果是空白区域，那么就按整体来做拖拽，如果是流式布局子元素，那么以这个子元素为准，如果是自由布局子元素，那么以这个资源素为准。

### 组件

- [组件注册与画布渲染](https://github.com/ascoders/weekly/blob/master/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%90%AD%E5%BB%BA/269.%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C%E4%B8%8E%E7%94%BB%E5%B8%83%E6%B8%B2%E6%9F%93.md)

#### 组件动态加载

用户第一次进入搭建平台时，是不可能直接加载所有组件的，组件一般是在使用时加载，这是因为组件是可扩展，加载所有组件会导致体验下降。所以编辑器需要一种异步的组件加载方式，有利于渲染单页面资源最优化。

技术难点

1. 如何解决组件公共库提取问题？
2. 如何解决组件版本兼容问题？

打包规范：现代前端模块化的发展趋势逐渐以 ESM 为主流，相比 AMD、CJS 有标准化组织支持，所以组件打包规范建议以 ESM 为目标。

- AMD
- CJS
- UMD
- ESM

加载方式：综合来说，使用 systemJS 加载模块是个更好的选择，对现代打包工具有较好的支持，有一套规范可以实现复杂的依赖引用，而且还支持各种模块的规范。

- SystemJS
- RequireJS

依赖分析：除了加载组件本身还远远不够，组件在实现时会依赖很多通用的基础库、框架，如按钮组件在 Web 端会依赖 React，具体依赖大概可分为以下三种类型。这三种类型的依赖，如果每一个组件都打包的话，无疑会造成很大的物料体积冗余，从而进一步影响拖拽体验，所以需要根据不同类型做不同的打包优化处理。

- 基础框架和库：React、ReactDOM、Vue、Lodash 等
  
    会作为公共依赖存在，组件打包时不会打包进该产物，该产物会直接内置在搭建平台侧，但要注意这些公共依赖需要在组件侧统一版本。

- 第三方库：Swiper 等特殊组件组件才需要使用的库。
  
    会一起打包进组件，不进行处理。

- 其他组件：如按钮列表组件需要按钮组件
  
    组件打包时，会检查当前组件依赖的其他组件，并声明在组件信息的某一字段中（如 dependencies），组件在加载时会先加载组件所需的物料.(注意组件加载方式是深度优先的，会存在多层依赖的场景。)

参考文献

- [低代码平台远程组件加载的多种方案](https://mp.weixin.qq.com/s?__biz=MzI2MjcxNTQ0Nw==&mid=2247500403&idx=1&sn=3470062142a9ad0ddbece75e915a1a5e&chksm=ea44632bdd33ea3d82074a59cfb0388e45e02cda07719672e4db40fd6d31a235b3e294732d78&mpshare=1&scene=1&srcid=0803kipweJuMt6e0ytTBVegH&sharer_sharetime=1659502754360&sharer_shareid=23bfc8f6684b676886641da1cfece5af&version=4.0.2.90474&platform=mac#rd)


#### 组件样式隔离

- 命名规范：BEM
- CSS Module
- CSS In JS
- Shadow DOM

#### 布局组件

争议点：自由布局 VS 流式布局

- 设计风格：不支持嵌套组件，但支持元素分组，在稿定、figama 等偏设计类的工具使用；
- 网站风格：支持嵌套组件，但是拖拽体验较差，需要较为熟悉前端 CSS 知识，自行配置样式熟悉来实现各种布局，在 webflow、阿里低代码引擎等站点编辑器上较为常见；

| 方式/竞品 | plasmic | webflow | 稿定  |
| ----- | ------- | ------- | --- |
| 自由布局  | ✓       | ✗       | ✗   |
| 流式布局  | ✗       | ✓       | ✗   |
| 弹性布局  | ✓       | ✓       | ✗   |
| 网格布局  | ✓       | ✓       | ✗   |

细节问题

- 布局切换：关注切换后的子组件位置和大小
  - plasmic：
    - 自由布局 =》非自由布局：重置子组件的位置样式
    - 非自由布局 =》自由布局：保留非自由布局的坐标位置
  - webflow：不支持自由布局，所以没有该问题
  - 稿定：不支持
- 子组件拖拽容易误拖拽到别的容器里
  市面上的编辑器暂时没有看到比较好的解决方案，是否可以考虑配合快捷键来实现，比如按住 shift 键表示拖拽组件始终在目标容器里，或者反转下：默认是在同级变动，需要按住 shift 或 command 键盘，才能脱出容器。
- ...

#### 自定义组件

竞品分析

| 方式/竞品           | plasmic          | webflow | figma       |
| --------------- | ---------------- | ------- | ----------- |
| 自定义组件           | ✓                | ✓       | ✓           |
| 变体属性（大小、类型、状态等） | ✓                | ✗       | ✓           |
| 显隐藏子组件          | ✓（需要使用变体属性，较为麻烦） | ✓       | ✓           |
| 映射子组件属性         | ✗                | ✓       | ✓           |
| 使用时定制子元素样式      | ✗                | ✗       | 除了位置和大小外的样式 |

功能要点

- 管理
  - 组件列表
  - 添加组件：设定组件名称信息
  - 修改组件：设定组件名称等信息
  - 编辑组件：默认提供一个容器组件，且不能删除
    - 支持自定义变体属性：布尔、选择，自动在画布上呈现对应变体元素供开发者调整
    - 子组件支持添加是否显示的组件属性，即使不提供，使用时也可以自行选择子组件来隐藏（相对比来说，更直观和方便）
    - 子组件支持将属性映射到自定义组件属性上（）
  - 删除组件：如果存在关联的组件，那么不可删除，且需要弹框确认是否要删除
- 使用:
  - 禁止在使用时调整子元素结构，必须编辑原始组件才行，或者使用开发的显隐藏属性来实现
  - 禁止调整元素的位置、边距和大小，只能设置文字和效果
  - 

技术要点：

- 需要设定独立的组件绘制画布，兼容原有的页面编辑
- 通过组件属性修改子元素 VS 直接修改子元素
  - 通过组件属性修改子元素：可以实现多个子元素复用同一个属性，而且配置组件时会更加的直观和严谨，但是实现较为复杂
  - 直接修改子元素：非常灵活且直观，用户想改哪里就点哪里，
- 直接对组件元素进行修改后，如何还原组件原有的值？
  - figma：在组件的属性右上角提供扩展菜单，可以重置
  - Webflow：不支持
  - plasmic：似乎不支持定制组件，修改时会直接影响原始组件
- 如何解决组件结构调整对已有实例的影响
- 自定义组件嵌套实现：允许在组件中添加其他自定义组件。
- 自定义组件循环依赖：需要检测循环依赖，避免出现该情况
  - 简单场景：存在自定义组件 A 和 B，A 依赖 B，B 依赖 A
  - 复杂场景：存爱自定义组件 A、B 和 C，A 依赖 B，B 依赖 C，C 依赖 A
- 组件元素样式合并计算和优先级问题
  - 存在样式：基础组件样式 < 外部定制样式 < 全局默认样式 < 自定义组件样式(含 mixins) < 页面元素样式(含 mixins) < 响应式配置样式(含 mixins)
  - 自定义组件样式合并

#### 组件插槽

需求背景

一个定制组件或自定义组件，需要支持在某个位置添加任意的其他组件，例如：

- 每个布局组件都有个默认插槽；
- Swiper 组件每一项都要支持插槽；

功能要点

- 组件支持设置是否有插槽，并且可以设置多个插槽；
- 图层需要区分显示不同的插槽；

竞品分析

| 特性 | figma | webflow | plasmic |
| --- | --- | --- | --- |
| 组件插槽 | 不支持 | 部分支持(Swiper)，自定义的组件不支持 | 支持 |


技术要点

#### 组件变体属性

TOOD

#### 组件动态数据

参考 [dynamic-data](./component/dynamic-data/README.md)

### 逻辑编排

- [精读《低代码逻辑编排》](https://github.com/ascoders/weekly/blob/master/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/197.%E7%B2%BE%E8%AF%BB%E3%80%8A%E4%BD%8E%E4%BB%A3%E7%A0%81%E9%80%BB%E8%BE%91%E7%BC%96%E6%8E%92%E3%80%8B.md)
- [RxEditor 逻辑编排](https://juejin.cn/post/7205361008272326716#heading-31)

    组件属性变更：

    - 每个组件的属性初始值来自编辑器生成的 Schema 配置属性；
    - 每个组件都有个额外的状态管理器，其内部的状态会覆盖自检 Schema 属性值；
    - 逻辑编排的时候可以修改状态管理器内的属性值；

    组件逻辑编排：

    1. 支持事件：初始化、销毁、点击
    2. 变量状态：可以定义一些额外的变量用于状态控制。
    3. 交互行为：

        - 通用交互：路由跳转、提示信息等
        - 组件控制：设置属性、变量赋值、监听变量、读取变量
        - 自定义：用于定制一些公共的交互行为，可供事件引用

    4. 逻辑编排：输入、输出、条件判断、循环、合并、延时、定时、随机、常量

    组件之间联动：

    1. 子组件可以调用父组件的的组件空值逻辑


### 样式

#### 大小输入框

- 支持多种单位切换
  如何解决切换单位时保持原有的位置和大小
- 支持响应式单位

#### 屏幕适配

适配场景

- Only mobile by max sacle：只适配移动端 + 缩放模式 + 限制最大缩放宽度（超出后限宽居中显示）
- Only PC by max scale：只适配 PC 端 + 缩放模式 + 限制最大缩放宽度（超出后限宽居中显示）
- Only PC by min width：只适配 PC 端 + 限制最小宽度（浏览器宽度小于该限制时横向滚动）
- Mobile by max sacle + PC by max scale
- Mobile/PC first by responsive

竞品分析：

| 定位/竞品 | webflow                                                                                                                                                  | plasmic                                                                                                                                          |
| ----- | -------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------ |
| 屏幕适配  | ✓                                                                                                                                                        | ✓                                                                                                                                                |
| 适配模式  | 媒体查询                                                                                                                                                     | 媒体查询                                                                                                                                             |
| 屏幕断点  | - Mobile Portrait：<= 479<br /><br />- Mobile Landscape：<= 767<br /><br />- Tablet：<= 991<br /><br />- Descktop：>= 992<br /><br /> <=1280 <= 1440 <= 1920 | Moble First：<br /><br />- Mobile：< 768<br /><br />- Desktop：>= 768<br /><br />Desktop First<br /><br />- Mobile：<=930<br /><br />- Desktop：> 930 |

| 设计/断点      | 断点                                                                                                                                                                                                     |
| ---------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Bootstrap  | - xs(portrait phones)：< 576<br /><br />- sm(landscape phones)：>= 576 & < 768<br /><br />- md(tablets)：>= 768 & < 992<br /><br />- lg(desktops)：>= 992 & < 1200<br /><br />- xl(large desktops)：>= 1200 |
| Ant Deisgn | 同 Bootstrap，但增加了个 super lage desktops：>= 1600                                                                                                                                                          |

- 业务组件内部元素的样式要如何适配不同屏幕？
  - 业务组件是用 vw 或 rem 进行屏幕适配，那么要如何确保在编辑器画布和真实设备一致呢？
  - 如果业务组件按特定的设计稿适配，但和画布框架的大小不匹配，要如何适配呢？
- 移动优先 VS PC 优先：前端生态一般推崇移动优先，但是在刚开始只设计配置了 PC 端的情况下， 要增加移动端的样式时，该如何保留 PC 端样式的前提下增加移动端设备。
  - webflow：限定了屏幕断点的值，默认样式为 >= 992 & < 1280，小于 992 的使用媒体查询 max-width 进行设定样式，大于 1280 的使用媒体查询 min-width 进行设定样式
  - plasmic：可以自定义屏幕断点的值，并且提供了移动优先和 PC 优先两种模式供选择，前者使用媒体查询 min-width 进行设定样式，后者使用媒体查询 max-width 进行设定样式。
- 如果拖动元素到特定的屏幕上时，其他屏幕该如何处理
  - Webflow：只支持样式响应式，不支持元素属性的响应式，在拖动元素到特定屏幕时，其他屏幕也会显示，并根据响应式来同步样式
  - Plasmic：支持样式和属性响应式，但拖动元素到特定屏幕时，只在特定屏幕显示对应元素，其他屏幕可以手动开启，然后按照 Mobile First 或 Desktop First 的方式进行屏幕复用
    总结：Plasmic 这种方式可以支持图片等媒体资源的响应式显示，但是其他类型的组件属性无法响应式实现，这样会导致服务端渲染出现问题(服务端无法获取屏幕大小信息，也就无法做响应式渲染)
- 元素属性显示响应式属性和样式：
  - 需要显示最终显示的属性值；
  - 需要标记继承自其他屏幕的属性值；
  - 需要标记修改后的属性值；
  - 需要提供清除修改的按钮；
- 

#### 组件定位

| 定位/竞品 | plasmic | webflow | 稿定  |
| ----- | ------- | ------- | --- |
| 默认定位  | ✓       | ✓       | ✗   |
| 相对定位  | ✗       | ✓       |     |
| 自由定位  | ✓       | ✓       | ✓   |
| 粘性定位  | ✓       | ✓       | ✗   |
| 固定定位  | ✓       | ✓       | ✗   |

细节问题

- 非自由布局容器 + 非默认定位子组件：子组件是否可以拖拽
  
  | 定位/竞品 | plasmic          | webflow          | 稿定  |
  | ----- | ---------------- | ---------------- | --- |
  | 相对定位  | 不支持              | 不可以拖拽，需要手动调整位置属性 | 不支持 |
  | 自由定位  | 支持拖拽             | 同上               | 不支持 |
  | 粘性定位  | 不支持拖拽，需要手动调整位置属性 | 同上               | 不支持 |
  | 固定定位  | 不支持拖拽，需要手动调整位置属性 | 同上               | 不支持 |

- 

#### 样式重用

竞品分析：

| 特性/竞品 | plasmic | webflow | 稿定  |
| ----- | ------- | ------- | --- |
| 样式重用  | ✓       | ✓       | ✗   |

功能要点：

- 管理
  - 样式列表
  - 新增/修改/复制样式
  - 查找样式引用关系
- 使用：在组件属性面板上支持关联配置重用样式
  - 按顺序迭代样式
  - 支持调整重用样式排序
  - 提供快捷按钮清除覆盖样式
  - 提供额外的按钮来提取样式作为重用样式

技术要点：

- 删除重用样式时该如何处理已关联应用的组件样式
  由于涉及到多个重用样式的叠加计算，现阶段只能忽略了。
- 在重用样式基础上自定义之后的清除和重置问题？
  - 场景一：需要在重用样式基础上微调
  - 场景二：在场景一基础上需要还原重用样式（提供清除按钮）
  - 场景三：清除掉部分重用样式

#### 样式变量

功能要点：

- 管理
  - 分组管理：根据样式类型不同进行分组管理，例如颜色变量和大小变量
    ps：plasmic 将变量划分了颜色、大小、字体类型、字体大小和行高，这些样式比较需要重用
  - 新增/修改/删除/复制样式变量：样式变量能够支持相互引用
  - 查找样式变量的引用关系：查看哪些元素在使用变量
- 使用：在对应样式输入框里支持搜索查找关联的样式变量

技术要点：

1. 要选择合适的样式类型作为变量管理
   例如：颜色、大小这样的样式适合使用变量来管理，而阴影样式这种的复杂样式，虽然可以使用变量来实现，但更建议使用样式重用来实现。
2. 要在哪些地方支持输入样式变量：特定 VS 任意
   - 特定：比较容易实现，可以忽略比边框等这样复杂样式内的变量关联，这类样式可以使用样式重用解决
   - 任意：在排查变量和属性的关联关系时叫我复杂，要考虑的场景较多
3. 在渲染的时候该如何解析样式变量？
   - CSS 变量：实现简单，但一些旧浏览器不支持
   - 自行解析：增加复杂度，且影响性能
4. 在删除样式变量的时候如何同步更新关联的样式
   如何查找？

### 资源

#### 字体

- 提取法：组件的字体样式提供所有可用的字体，运行的时候收集所有实际使用到的字体，然后插入对应的字体样式
  
  - 优点：操作简单，用户可以直接使用大部分字体
  - 缺点：收集逻辑较为复杂，如果遇到动态样式时难以实现

- 预设法：全局统一添加可用的字体，组件的字体样式只显示已经添加的字体，运行的时候加载预设字体节课。
  
  - 优点：实现简单，运行时只有加载全局配置的字体即可
  - 缺点：操作没那么快捷，用户需要预设好字体

ps：如何解决字体文件较大的问题？参照使用 google 字体的 unicode-range。

#### 国际化

1. 开发特定的国际化业务组件，只有特定组件才支持国际化，多语言的设置和渲染都交给特定业务组件处理；

2. 全局配置国际化语言，在文本输入框里输入关联标识（支持自动完成）
   
   - 然后在渲染的时候通过插件遍历字段来替换文案（影响性能？）
   
   - 所有文本渲染都交给特殊组件处理，该组件会自行格式化实现。

3. 组件属性区分多语言设置

可以解决素材、样式等国际化，但遇到复用的情况下，与无法解决配置冗余。

最终采用方案 2，文本交给特殊组件处理。

输入框组件的交互设计

- 未输入国际化信息
  
  - 点击打开国际化选择器
  - 选择某条国际化信息，然后更新输入信息为国际化标识符，输入框自动获取焦点
  - 选择器默认不关闭，可供二次选择，需要的话手动关闭

- 已输入国际化信息：不可输入任何信息，必须先清除国际化信息后才允许
  
  - 获取焦点
    
    - 自动打开国际化选择器
    - 可以选择切换信息
  
  - 清除
    
    - 可以选中清除
    - 清楚后自动关闭选择器

### 事件

事件体系是进一步解耦的设计方案，编辑器中会建设一套完善的事件体系，对应着每个编辑动作、渲染动作、全局动作的生命周期或者具体的回调动作，每个功能模块都可消费相应的事件。如此设计的好处是利于扩展，当添加新 feature 时，可以很容易地通过挂载事件来做到，而插件机制也真是基于事件来完成的。

- 编辑器生命周期事件
- 元素生命周期事件
- 组件注册事件
- 画布操作事件
- 快捷键事件

事件实现方式

- EventTarget：原生支持，且支持事件冒泡和取消；
- EventEmiiter：不支持事件冒泡和取消功能；

### 插件

开发二次封装使用的扩展方式。

- 如何解决编辑器不同区域快捷键冲突问题

### 扩展

类似于浏览器扩展，相对比插件更加开发和标准化。

### 安全

#### XSS 攻击

- 问题：富文本内容存储在 DSL 数据中一起保存时，服务端不好做 XSS 攻击脚本的过滤（无法知道哪个字段存储的是富文本，除非遍历）
- 解决：将富文本字段编辑的内存独立保存到 DSL 的某个全局属性上，服务端可以针对对应的属性做统一的过滤

### 协同

- [低代码多分支协同开发的建设与实践](https://mp.weixin.qq.com/s/DmwxL67htHfTUP1U966N-Q?utm_oi=35897751896064&utm_source=pocket_reader)

### 跨框架

- iframe：在 tmagic 中出现，对开发者来说使用较为复杂，但可以实现多种运行框架，而且可以较好的隔离样式和实现响应式等特性
- 其他编辑器比较少见使用 iframe 的，开发者使用起来较为简单，但缺乏对多种运行框架和响应式等特性的支持

## 参考文献

- [页面可视化搭建工具前生今世](https://github.com/CntChen/cntchen.github.io/issues/15)
- [云凤蝶可视化搭建的推导与实现](https://zhuanlan.zhihu.com/p/90746742)
- [前端可视化搭建二三事](https://github.com/SunXinFei/sunxinfei.github.io/issues/26)
- [「可视化搭建系统」——从设计到架构，探索前端的领域和意义](https://juejin.im/post/5f1e98c05188252e5522dc0c)
- [这可能是目前最好用的开源可视化拖拽框架](https://juejin.cn/post/6990000320822657031)
- [基于自然流布局的H5编辑器brick design 项目篇](https://juejin.cn/post/6883099504480878600)
- [我用 Vue +Fabric.js写了个简易的H5可视化图片编辑器](https://juejin.cn/post/6994365575027752967)
- [从零设计可视化大屏搭建引擎](https://juejin.cn/post/6981257575425654792)
- [Vue + Egg 实现一个 H5页面可视化编辑器 / 可视化配置平台](https://juejin.cn/post/7001077797808504839)
- [设计系统的未来](https://www.bilibili.com/video/BV1KG4y1x75q/?spm_id_from=333.337.search-card.all.click&vd_source=2e69ba889e556e858093542d78fc08c0) / [Subcomponents](https://medium.com/eightshapes-llc/subcomponents-753ce9f6600a)

综合

- [前端页面可视化搭建工具业界的轮子](https://juejin.cn/post/6858881797490098190) / [20+个前端可视化搭建工具，一次玩个够](https://jishuin.proginn.com/p/763bfbd52af4)

- [「可视化搭建系统」——从设计到架构，探索前端领域技术和业务价值](https://zhuanlan.zhihu.com/p/164558106)

- [页面可视化搭建工具技术要点](https://github.com/CntChen/cntchen.github.io/issues/17)

- [可视化搭建的一些思考和实践](https://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA%3D%3D&chksm=fc530835cb2481233acc7ac2c856b30c7698dd9d2aec1514b5c2fa4165bc2728f7b261c4938f&idx=1&mid=2247487950&scene=21&sn=e674a2f9379b9c9b8a149498a50c17f8&utm_source=pocket_reader)

- [Spotify 如何可视化系统架构图](https://www.infoq.cn/article/s5UwbP01ga8akJIFgtZV?utm_source=pocket_saves)

- [基于 React 的可视化编辑平台实践](https://zhuanlan.zhihu.com/p/94016600?utm_oi=35897751896064&utm_source=pocket_reader)

- [技术周报· 基于设计稿识别的可视化低代码系统实践](https://mp.weixin.qq.com/s/JUXz9TOKbkO1oAzHjVfwnQ)

- [可视化拖拽组件库一些技术要点原理分析](https://github.com/woai3c/Front-end-articles/issues/19)
  
  - [可视化拖拽组件库一些技术要点原理分析（二）](https://github.com/woai3c/Front-end-articles/issues/20)
  - [可视化拖拽组件库一些技术要点原理分析（三）](https://github.com/woai3c/Front-end-articles/issues/21)
  - [可视化拖拽组件库一些技术要点原理分析（四）](https://segmentfault.com/a/1190000042282658)

画布

- [浅谈搭建平台 - 画布篇](https://mp.weixin.qq.com/s/pfWplWHajZDcsOH_m3rUMw)
- [可视化搭建平台之跨iframe拖拽](https://zhuanlan.zhihu.com/p/353043053?utm_oi=35897751896064&utm_source=pocket_reader)

数据

- [如何设计实现 h5 页面搭建-数据模型](https://mp.weixin.qq.com/s/Fyl3SMHjv3ROw9QUBdwutA?utm_source=pocket_reader)

案例

- [美团外卖前端可视化界面组装平台 —— 乐高](https://zhuanlan.zhihu.com/p/27288444?utm_source=pocket_reader)
- [我在闲鱼做搭建——魔鱼搭投编辑器介绍](https://zhuanlan.zhihu.com/p/538265765?utm_oi=35897751896064&utm_source=pocket_reader)
- [从零开发一款图片编辑器Mitu-Dooring](https://mp.weixin.qq.com/s/SEIgiDJZOCX11JqxFdiKUw)
- [我也做了一个可视化H5编辑器](https://juejin.cn/post/6919347925860499463)
- [可视化搭建移动端店铺解决方案](https://mp.weixin.qq.com/s?__biz=MzU2Mzk1NzkwOA%3D%3D&chksm=fc530e9acb24878c90ce680610dd0a339dccdf2e04aea0ef815b71178c137032c3f8afbfa02a&cur_album_id=1885104505269108738&idx=1&mid=2247489377&scene=189&sn=2f205a9519c8f0e391f1e7473851153d&utm_source=pocket_saves)
- [凹凸技术揭秘·羚珑页面可视化·成长蜕变之路](https://segmentfault.com/a/1190000038792146)
- [从零开发一款图片编辑器Mitu-Dooring](https://mp.weixin.qq.com/s/SEIgiDJZOCX11JqxFdiKUw)

开源

- [rxeditor](https://github.com/rxdrag/rxeditor)

讨论

- [我做了一个 HTML 可视化编辑工具，有前途吗？](https://www.zhihu.com/question/390956688/answer/1184696066?utm_oi=35897751896064&utm_source=pocket_reader)
